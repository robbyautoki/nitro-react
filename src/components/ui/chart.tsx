import * as React from 'react';
import * as RechartsPrimitive from 'recharts';
import { cn } from '@/lib/utils';

export type ChartConfig = {
    [k in string]: {
        label?: React.ReactNode;
        icon?: React.ComponentType;
    } & (
        | { color?: string; theme?: never }
        | { color?: never; theme: Record<'light' | 'dark', string> }
    );
};

type ChartContextProps = { config: ChartConfig };
const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart()
{
    const context = React.useContext(ChartContext);
    if(!context) throw new Error('useChart must be used within a <ChartContainer />');
    return context;
}

// Note: The ChartStyle component uses dangerouslySetInnerHTML to inject CSS variables
// for chart colors. This is safe because the values come from the developer-defined
// ChartConfig object (not user input) and are CSS color values only.
function ChartContainer({ id, className, children, config, ...props }: React.ComponentProps<'div'> & {
    config: ChartConfig;
    children: React.ComponentProps<typeof RechartsPrimitive.ResponsiveContainer>['children'];
})
{
    const uniqueId = React.useId();
    const chartId = `chart-${ id || uniqueId.replace(/:/g, '') }`;

    return (
        <ChartContext.Provider value={ { config } }>
            <div
                data-chart={ chartId }
                className={ cn(
                    'flex aspect-video justify-center text-xs',
                    '[&_.recharts-cartesian-axis-tick_text]:fill-white/50',
                    '[&_.recharts-cartesian-grid_line[stroke=\'#ccc\']]:stroke-white/10',
                    '[&_.recharts-curve.recharts-tooltip-cursor]:stroke-white/30',
                    '[&_.recharts-rectangle.recharts-tooltip-cursor]:fill-white/5',
                    '[&_.recharts-reference-line_[stroke=\'#ccc\']]:stroke-white/10',
                    '[&_.recharts-dot[stroke=\'#fff\']]:stroke-transparent',
                    '[&_.recharts-layer]:outline-hidden',
                    '[&_.recharts-sector]:outline-hidden',
                    '[&_.recharts-surface]:outline-hidden',
                    className
                ) }
                { ...props }
            >
                <ChartStyle id={ chartId } config={ config } />
                <RechartsPrimitive.ResponsiveContainer>
                    { children }
                </RechartsPrimitive.ResponsiveContainer>
            </div>
        </ChartContext.Provider>
    );
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) =>
{
    const colorConfig = Object.entries(config).filter(([, c]) => c.theme || c.color);
    if(!colorConfig.length) return null;

    // Safe: values are developer-defined CSS colors from ChartConfig, not user input
    const cssVars = colorConfig
        .map(([key, itemConfig]) =>
        {
            const color = itemConfig.theme?.dark || itemConfig.color;
            return color ? `  --color-${ key }: ${ color };` : null;
        })
        .filter(Boolean)
        .join('\n');

    return (
        <style
            dangerouslySetInnerHTML={ { __html: `[data-chart=${ id }] {\n${ cssVars }\n}` } }
        />
    );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

function ChartTooltipContent({
    active, payload, className, indicator = 'dot', hideLabel = false, hideIndicator = false,
    label, labelFormatter, labelClassName, formatter, color, nameKey, labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> & React.ComponentProps<'div'> & {
    hideLabel?: boolean; hideIndicator?: boolean; indicator?: 'line' | 'dot' | 'dashed';
    nameKey?: string; labelKey?: string;
})
{
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() =>
    {
        if(hideLabel || !payload?.length) return null;
        const [item] = payload;
        const key = `${ labelKey || item?.dataKey || item?.name || 'value' }`;
        const itemConfig = getPayloadConfigFromPayload(config, item, key);
        const value = !labelKey && typeof label === 'string'
            ? config[label as keyof typeof config]?.label || label
            : itemConfig?.label;

        if(labelFormatter) return <div className={ cn('font-medium', labelClassName) }>{ labelFormatter(value, payload) }</div>;
        if(!value) return null;
        return <div className={ cn('font-medium', labelClassName) }>{ value }</div>;
    }, [ label, labelFormatter, payload, hideLabel, labelClassName, config, labelKey ]);

    if(!active || !payload?.length) return null;

    const nestLabel = payload.length === 1 && indicator !== 'dot';

    return (
        <div className={ cn('grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-white/10 bg-[rgba(12,12,16,0.95)] px-2.5 py-1.5 text-xs text-white/80 shadow-xl', className) }>
            { !nestLabel ? tooltipLabel : null }
            <div className="grid gap-1.5">
                { payload
                    .filter(item => item.type !== 'none')
                    .map((item, index) =>
                    {
                        const key = `${ nameKey || item.name || item.dataKey || 'value' }`;
                        const itemConfig = getPayloadConfigFromPayload(config, item, key);
                        const indicatorColor = color || (item.payload as Record<string, unknown>)?.fill as string || item.color;

                        return (
                            <div key={ item.dataKey } className={ cn('flex w-full flex-wrap items-stretch gap-2', indicator === 'dot' && 'items-center') }>
                                { formatter && item?.value !== undefined && item.name
                                    ? formatter(item.value, item.name, item, index, item.payload)
                                    : (
                                        <>
                                            { itemConfig?.icon
                                                ? <itemConfig.icon />
                                                : (!hideIndicator && (
                                                    <div
                                                        className={ cn('shrink-0 rounded-[2px]', {
                                                            'h-2.5 w-2.5': indicator === 'dot',
                                                            'w-1': indicator === 'line',
                                                            'w-0 border-[1.5px] border-dashed bg-transparent': indicator === 'dashed',
                                                        }) }
                                                        style={ { backgroundColor: indicatorColor, borderColor: indicatorColor } }
                                                    />
                                                )) }
                                            <div className={ cn('flex flex-1 justify-between leading-none', nestLabel ? 'items-end' : 'items-center') }>
                                                <div className="grid gap-1.5">
                                                    { nestLabel ? tooltipLabel : null }
                                                    <span className="text-white/50">{ itemConfig?.label || item.name }</span>
                                                </div>
                                                { item.value !== undefined && (
                                                    <span className="font-mono font-medium tabular-nums text-white">
                                                        { typeof item.value === 'number' ? item.value.toLocaleString() : item.value }
                                                    </span>
                                                ) }
                                            </div>
                                        </>
                                    ) }
                            </div>
                        );
                    }) }
            </div>
        </div>
    );
}

const ChartLegend = RechartsPrimitive.Legend;

function ChartLegendContent({ className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey }: React.ComponentProps<'div'> & Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & { hideIcon?: boolean; nameKey?: string })
{
    const { config } = useChart();
    if(!payload?.length) return null;

    return (
        <div className={ cn('flex items-center justify-center gap-4', verticalAlign === 'top' ? 'pb-3' : 'pt-3', className) }>
            { payload
                .filter(item => item.type !== 'none')
                .map(item =>
                {
                    const key = `${ nameKey || item.dataKey || 'value' }`;
                    const itemConfig = getPayloadConfigFromPayload(config, item, key);

                    return (
                        <div key={ item.value } className="flex items-center gap-1.5 text-white/60">
                            { itemConfig?.icon && !hideIcon
                                ? <itemConfig.icon />
                                : <div className="h-2 w-2 shrink-0 rounded-[2px]" style={ { backgroundColor: item.color } } /> }
                            { itemConfig?.label }
                        </div>
                    );
                }) }
        </div>
    );
}

function getPayloadConfigFromPayload(config: ChartConfig, payload: unknown, key: string)
{
    if(typeof payload !== 'object' || payload === null) return undefined;
    const payloadPayload = 'payload' in payload && typeof payload.payload === 'object' && payload.payload !== null ? payload.payload : undefined;
    let configLabelKey: string = key;

    if(key in payload && typeof (payload as Record<string, unknown>)[key] === 'string')
    {
        configLabelKey = (payload as Record<string, unknown>)[key] as string;
    }
    else if(payloadPayload && key in payloadPayload && typeof (payloadPayload as Record<string, unknown>)[key] === 'string')
    {
        configLabelKey = (payloadPayload as Record<string, unknown>)[key] as string;
    }

    return configLabelKey in config ? config[configLabelKey] : config[key as keyof typeof config];
}

export { ChartContainer, ChartTooltip, ChartTooltipContent, ChartLegend, ChartLegendContent, ChartStyle };
